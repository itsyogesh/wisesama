generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Core entity types
enum EntityType {
  ADDRESS
  DOMAIN
  TWITTER
  EMAIL
}

enum RiskLevel {
  SAFE // Verified/Whitelisted (score 0-19)
  UNKNOWN // No data (score: null)
  CAUTION // Suspicious (score 40-69)
  FRAUD // Confirmed malicious (score 70-100)
}

enum ThreatCategory {
  PHISHING
  SCAM
  RUG_PULL
  IMPERSONATION
  FAKE_AIRDROP
  RANSOMWARE
  MIXER
  OFAC_SANCTIONED
  OTHER
}

// Identity source for unified identity storage
enum IdentitySource {
  POLKADOT_PEOPLE // Polkadot People Chain identity
  KUSAMA_PEOPLE // Kusama People Chain identity
  KILT // KILT DID (future support)
}

// Whitelist request workflow status
enum WhitelistRequestStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
}

// Activity types for audit logging
enum ActivityType {
  WHITELIST_CREATED
  WHITELIST_UPDATED
  WHITELIST_DELETED
  REQUEST_SUBMITTED
  REQUEST_APPROVED
  REQUEST_REJECTED
  REPORT_VERIFIED
  REPORT_REJECTED
  SYNC_COMPLETED
  ADMIN_LOGIN
}

model Chain {
  id                  Int                 @id @default(autoincrement())
  code                String              @unique // 'dot', 'ksm', 'astr'
  name                String // 'Polkadot', 'Kusama'
  ss58Prefix          Int
  rpcEndpoint         String?
  explorerUrl         String?
  isActive            Boolean             @default(true)
  entities            Entity[]
  identities          Identity[]          @relation("identities")
  whitelistedEntities WhitelistedEntity[]
  whitelistRequests   WhitelistRequest[]
}

model Entity {
  id              String     @id @default(cuid())
  entityType      EntityType
  value           String // Original value
  normalizedValue String // Lowercase/normalized
  chainId         Int?
  chain           Chain?     @relation(fields: [chainId], references: [id])

  // Risk assessment
  riskLevel      RiskLevel       @default(UNKNOWN)
  riskScore      Int? // 0-100
  threatCategory ThreatCategory?

  // Source tracking
  source     String  @default("unknown")
  sourceUrl  String? // Related phishing URL
  threatName String? // Category from phishing list

  // Stats
  timesSearched   Int       @default(0)
  lastSearchedAt  DateTime?
  userReportCount Int       @default(0)

  // Timestamps
  firstReportedAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  reports  Report[]
  searches Search[]
  comments EntityComment[]

  @@unique([entityType, normalizedValue])
  @@index([normalizedValue])
  @@index([riskLevel])
  @@index([source])
}

// Unified identity table supporting multiple sources (People chains, KILT, etc.)
model Identity {
  id      String         @id @default(cuid())
  address String
  source  IdentitySource

  // Optional chain relation (for filtering by ecosystem)
  chainId Int?
  chain   Chain? @relation("identities", fields: [chainId], references: [id])

  // Identity fields (normalized on write)
  displayName String?
  legalName   String?
  email       String?
  twitter     String? // Normalized: lowercase, no @ prefix
  web         String? // Normalized: lowercase, no protocol/www
  riot        String?

  // KILT-specific fields (for future use)
  kiltDid           String?
  kiltCredentialUri String?

  // Verification
  hasIdentity Boolean @default(false)
  isVerified  Boolean @default(false)
  judgements  Json    @default("[]") // [{registrar_id, judgement}]

  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Composite unique: same address can have identities from different sources
  @@unique([address, source])
  @@index([address])
  @@index([source])
  @@index([isVerified])
  @@index([twitter]) // For reverse lookups
  @@index([web]) // For reverse lookups
  @@index([twitter, isVerified])
  @@index([web, isVerified])
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id            String   @id @default(cuid())
  email         String   @unique
  passwordHash  String?
  walletAddress String? // Polkadot wallet for Web3 auth
  role          UserRole @default(USER)

  // Quota
  remainingQuota Int    @default(100)
  tier           String @default("free")

  isVerified Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  apiKeys           ApiKey[]
  reports           Report[]
  searches          Search[]
  watchedAddresses  WatchedAddress[]
  whitelistRequests WhitelistRequest[]
}

model ApiKey {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  keyHash   String  @unique // SHA256 hash
  keyPrefix String // First 8 chars for display
  name      String?

  remainingQuota  Int @default(10000)
  rateLimitPerMin Int @default(60)

  isActive   Boolean   @default(true)
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([keyHash])
}

model Report {
  id       String  @id @default(cuid())
  userId   String?
  user     User?   @relation(fields: [userId], references: [id])
  entityId String?
  entity   Entity? @relation(fields: [entityId], references: [id])

  reportedValue  String
  entityType     EntityType
  threatCategory ThreatCategory
  otherCategory  String?
  description    String?
  relatedUrl     String?
  evidenceUrls   String[]       @default([])

  // Reporter info (if not logged in)
  reporterName  String?
  reporterEmail String?

  status     String    @default("pending") // pending, verified, rejected
  reviewedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Community contribution (auto-PR to polkadot-js/phishing)
  contribution CommunityContribution?

  @@index([status])
  @@index([entityType])
}

// Track PRs submitted to polkadot-js/phishing repository
model CommunityContribution {
  id       String @id @default(cuid())
  reportId String @unique
  report   Report @relation(fields: [reportId], references: [id])

  // GitHub PR info
  prNumber Int?
  prUrl    String?
  prStatus String  @default("pending") // pending, open, merged, closed, error

  // What was contributed
  entityType  EntityType
  entityValue String
  targetFile  String // "address.json" or "all.json"

  // Tracking
  submittedAt  DateTime?
  mergedAt     DateTime?
  errorMessage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([prStatus])
}

model Search {
  id             String      @id @default(cuid())
  searchTerm     String
  normalizedTerm String
  entityType     EntityType?
  entityId       String?
  entity         Entity?     @relation(fields: [entityId], references: [id])

  userId     String?
  user       User?   @relation(fields: [userId], references: [id])
  apiKeyUsed String?

  resultRisk     RiskLevel?
  responseTimeMs Int?
  cacheHit       Boolean    @default(false)

  searchedAt DateTime @default(now())

  @@index([searchedAt])
  @@index([normalizedTerm])
}

model WatchedAddress {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  address    String
  chain      String  @default("dot")
  webhookUrl String?

  isActive    Boolean   @default(true)
  lastAlertAt DateTime?
  createdAt   DateTime  @default(now())

  @@unique([userId, address, chain])
  @@index([address])
}

model EntityComment {
  id       String @id @default(cuid())
  entityId String
  entity   Entity @relation(fields: [entityId], references: [id])

  comment     String
  authorName  String?
  authorEmail String?

  isApproved Boolean  @default(true)
  createdAt  DateTime @default(now())

  @@index([entityId])
}

model SyncState {
  id               String    @id @default(cuid())
  sourceName       String    @unique // 'polkadot-js-phishing'
  lastSyncAt       DateTime?
  lastSyncHash     String? // Content hash for change detection
  recordsProcessed Int       @default(0)
  lastError        String?
  metadata         Json      @default("{}")
}

// Ecosystem Whitelist - Top projects, validators, exchanges
model WhitelistedEntity {
  id              String     @id @default(cuid())
  entityType      EntityType
  value           String // Address, domain, handle
  normalizedValue String
  chainId         Int?
  chain           Chain?     @relation(fields: [chainId], references: [id])

  // Entity info
  name        String // "Polkadot Treasury", "Parity Technologies"
  category    String // "exchange", "validator", "treasury", "project"
  description String?
  website     String?
  twitter     String?
  logoUrl     String?

  // Verification
  source     String // "manual", "governance", "subscan", "request"
  verifiedAt DateTime?
  verifiedBy String? // Admin who verified

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-relation to approval request (if created via request workflow)
  whitelistRequest WhitelistRequest?

  @@unique([entityType, normalizedValue])
  @@index([category])
  @@index([name])
}

// Whitelist request workflow - public submissions for whitelist inclusion
model WhitelistRequest {
  id String @id @default(cuid())

  // Entity details
  entityType      EntityType
  value           String
  normalizedValue String
  chainId         Int?
  chain           Chain?     @relation(fields: [chainId], references: [id])

  // Project/Entity info
  name        String
  category    String // project, validator, exchange, etc.
  description String?
  website     String?
  twitter     String?
  logoUrl     String?

  // Requester info - supports both anonymous and logged-in users
  userId         String? // Link to User if logged in
  user           User?   @relation(fields: [userId], references: [id])
  requesterName  String? // Fallback for anonymous
  requesterEmail String // Required for notifications
  requesterOrg   String?

  // Evidence for verification
  evidenceUrls      String[] @default([])
  verificationNotes String?

  // Review workflow
  status          WhitelistRequestStatus @default(PENDING)
  reviewedAt      DateTime?
  reviewedBy      String?
  reviewNotes     String?
  rejectionReason String?

  // Link to created entity (if approved)
  whitelistedEntityId String?            @unique
  whitelistedEntity   WhitelistedEntity? @relation(fields: [whitelistedEntityId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([userId])
  @@index([requesterEmail])
  @@index([createdAt])
}

// Audit trail for admin actions
model ActivityLog {
  id          String       @id @default(cuid())
  type        ActivityType
  description String
  userId      String?
  userEmail   String?
  entityType  String?
  entityId    String?
  metadata    Json         @default("{}")
  ipAddress   String?
  createdAt   DateTime     @default(now())

  @@index([type])
  @@index([createdAt])
}
